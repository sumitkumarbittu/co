<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Secure Chat</title>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            height: 100%;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            background-color: #000;
            color: #0f0;
        }

        /* Blank Screen Wrapper */
        #blank-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hidden Input for Mobile Keyboard */
        #hidden-input {
            position: absolute;
            opacity: 0;
            width: 1px;
            height: 1px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            /* Let clicks pass through to the blank screen handler */
        }

        /* Loading/Status Indicator */
        #status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 10px;
            color: #444;
        }
    </style>
</head>

<body>

    <!-- 1. Overlay / Blank Screen (Always present initially) -->
    <div id="blank-screen">
        <!-- Hidden input to capture password and trigger keyboard on mobile -->
        <input type="text" id="hidden-input" autocomplete="off" />
    </div>

    <!-- 2. Chat Interface (Injected dynamically) -->
    <div id="app-root" style="height: 100%"></div>

    <div id="status">Disconnected</div>

    <script>
        // --- Configuration ---
        // UPDATE THIS URL AFTER DEPLOYING TO RENDER
        const RENDER_BACKEND_URL = 'https://co2026.onrender.com';

        const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const API_BASE_URL = (isLocal || window.location.origin.includes('github.io')) && !isLocal ? RENDER_BACKEND_URL : '';

        console.log('API Base:', API_BASE_URL || 'Relative Path');

        // --- State Management ---
        const INACTIVITY_LIMIT = 5000; // 5 seconds
        let inactivityTimer;
        let isLocked = true;
        let isAuthenticated = false;
        let pollingInterval = null;
        let loginDebounceTimer = null;

        // Elements
        const blankScreen = document.getElementById('blank-screen');
        const hiddenInput = document.getElementById('hidden-input');
        const appRoot = document.getElementById('app-root');
        const statusDiv = document.getElementById('status');

        // Dynamic Elements (set after injection)
        let messagesDiv = null;
        let messageInput = null;
        let inputForm = null;

        // --- Inactivity Logic ---
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            if (isAuthenticated && !isLocked) {
                inactivityTimer = setTimeout(lockScreen, INACTIVITY_LIMIT);
            }
        }

        function lockScreen() {
            isLocked = true;
            blankScreen.style.display = 'flex';
            if (appRoot) appRoot.style.display = 'none';
            stopPolling();
            hiddenInput.value = ''; // Clear typed password
            statusDiv.textContent = 'Locked';
            console.log('Screen Locked');
        }

        function unlockScreen() {
            isLocked = false;
            blankScreen.style.display = 'none';
            if (appRoot) appRoot.style.display = 'block';
            if (messageInput) messageInput.focus();
            startPolling();
            resetInactivityTimer();
            statusDiv.textContent = 'Active';
        }

        // --- Interaction Listeners for Inactivity ---
        ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
            document.addEventListener(evt, () => {
                if (!isLocked) resetInactivityTimer();
            });
        });

        // --- Blank Screen Logic ---
        // Clicking anywhere on the blank screen focuses the hidden input
        blankScreen.addEventListener('click', () => {
            hiddenInput.focus();
        });

        // Handle Password Input with Debounce (Stealth Mode)
        hiddenInput.addEventListener('input', (e) => {
            const val = e.target.value;

            clearTimeout(loginDebounceTimer);
            // Wait 800ms after last keystroke to check password
            loginDebounceTimer = setTimeout(() => {
                attemptLogin(val);
            }, 800);
        });

        async function attemptLogin(password) {
            try {
                const url = API_BASE_URL ? `${API_BASE_URL}/api/login` : '/api/login';

                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password }),
                    credentials: 'include'
                });

                if (res.ok) {
                    const data = await res.json();
                    if (data.success && data.ui) {
                        isAuthenticated = true;
                        injectChatUI(data.ui);
                        hiddenInput.value = ''; // Clear password
                        unlockScreen();
                    } else if (data.success && !data.ui) {
                        console.error('Login successful but UI payload missing. Backend might be stale.');
                    }
                } else {
                    // Silent failure for stealth
                    console.log('Auth check failed');
                }
            } catch (err) {
                console.error('Login error', err);
            }
        }

        function injectChatUI(htmlContent) {
            // Only inject if not already there or if we want to refresh
            if (!document.getElementById('chat-container')) {
                appRoot.innerHTML = htmlContent;

                // Re-bind elements
                messagesDiv = document.getElementById('messages');
                messageInput = document.getElementById('message-input');
                inputForm = document.getElementById('input-area');

                // Bind Chat Events
                inputForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const content = messageInput.value;
                    if (!content) return;

                    try {
                        const url = API_BASE_URL ? `${API_BASE_URL}/api/messages` : '/api/messages';

                        await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content }),
                            credentials: 'include'
                        });
                        messageInput.value = '';
                        fetchMessages();
                        resetInactivityTimer();
                    } catch (err) {
                        console.error('Send error', err);
                    }
                });
            }
        }

        // --- Chat Logic ---
        async function fetchMessages() {
            if (isLocked) return;
            try {
                const url = API_BASE_URL ? `${API_BASE_URL}/api/messages` : '/api/messages';

                const res = await fetch(url, {
                    credentials: 'include'
                });
                if (res.status === 401) {
                    lockScreen();
                    isAuthenticated = false;
                    return;
                }
                const data = await res.json();
                renderMessages(data);
            } catch (err) {
                console.error('Fetch error', err);
            }
        }

        function renderMessages(msgs) {
            if (!messagesDiv) return;
            messagesDiv.innerHTML = msgs.map(m => `
                <div class="message" style="margin-bottom: 8px; word-wrap: break-word;">
                    <span class="time" style="font-size: 0.8em; color: #666; margin-right: 8px;">[${new Date(m.created_at).toLocaleTimeString()}]</span>
                    <span class="content">${escapeHtml(m.content)}</span>
                </div>
            `).join('');
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function escapeHtml(text) {
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function startPolling() {
            if (pollingInterval) clearInterval(pollingInterval);
            fetchMessages();
            pollingInterval = setInterval(fetchMessages, 2000);
        }

        function stopPolling() {
            if (pollingInterval) clearInterval(pollingInterval);
            pollingInterval = null;
        }

    </script>
</body>

</html>